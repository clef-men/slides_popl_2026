\newcommand{\angles}[2][]{%
  \langle\ %
  \ifx #1\empty \else%
    \v{#1} \ldotp \,%
  \fi%
  #2%
  \ \rangle%
}

\section{Physical equality}

%\begin{frame}{Classification of \Zoo values}
%\LARGE
%\begin{itemize}
%  \item boolean
%  \item integer
%  \item \textcolor{color2}{mutable block (pointer)}
%  \item \textcolor{color2}{immutable block (tag and fields)}
%  \item function
%\end{itemize}
%\end{frame}

\begin{frame}[fragile]{Physical equality in \emph{fine-grained} concurrent programs}
\large
\strut
\vfill
\begin{overprint}
\onslide<1>
\begin{minted}[escapeinside=??]{ocaml}
type 'a t =
  'a list Atomic.t

let create () =
  Atomic.make []

let rec push t v =
  let old = Atomic.get t in
  let ?new? = v :: old in
  if Atomic.compare_and_set t old ?new? then
    ()
  else
    push t v
\end{minted}
\onslide<2->
\begin{minted}[escapeinside=??]{text}
type 'a t =
  'a list Atomic.t

let create () =
  Atomic.make []

let rec push t v =
  let old = Atomic.get t in
  let new = v :: old in
  if ?\textcolor{color2}{Atomic.compare\_and\_set}\tikzmark{mark}? t old new then
    ()
  else
    push t v
\end{minted}
\end{overprint}
\only<2->{
  \def\x{\textwidth*0.55}
  \def\y{\textheight*1/2}
  \def\dx{\textwidth*1/50}
  \def\dy{\textheight*1/15}
  \begin{tikzpicture}[remember picture]
    \draw [overlay, ->, line width=1pt, color2, opacity=.5] (\x,\y) node [above right, opacity=1] {\textbf{Physical comparison \texttt{(==)}}} -- ([yshift=.8em] pic cs:mark) ;
    \only<3->{
      \draw [overlay, color2] (\x+\dx,\y-\dy) node [above right] {\OCaml: under-specified} ;
    }
    \only<4->{
      \draw [overlay, color2] (\x+\dx,\y-2*\dy) node [above right] {\HeapLang: too restrictive} ;
      \draw [overlay, color2] (\x+\dx,\y-3*\dy) node [above right] {\phantom{\HeapLang: }incompatible w/ \OCaml} ;
    }
  \end{tikzpicture}
}
\end{frame}

\begin{frame}[fragile]{When physical equality returns \c{true}}
\large
\begin{overprint}
\onslide<1>
\begin{minted}[escapeinside=??]{text}
let rec push t v =
  let old = Atomic.get t in
  let new = v :: old in
  
  if ?\textcolor{color2}{Atomic.compare\_and\_set}? t old new then
    
    
    ()
  else
    push t v
\end{minted}
\onslide<2>
\begin{minted}[escapeinside=??]{text}
let rec push t v =
  let old = Atomic.get t in
  let new = v :: old in
  ?\textcolor{color1}{$\angles[vs]{\l{stack-model}\ t\ \v{vs} \iSep \ldots }$}?
  if ?\textcolor{color2}{Atomic.compare\_and\_set}? t old new then
    
    
    ()
  else
    push t v
\end{minted}
\onslide<3>
\begin{minted}[escapeinside=??]{text}
let rec push t v =
  let old = Atomic.get t in
  let new = v :: old in
  ?\textcolor{color1}{$\angles[vs]{\l{stack-model}\ t\ \v{vs} \iSep \ldots }$}?
  if ?\textcolor{color2}{Atomic.compare\_and\_set}? t old new then
    ?\textcolor{color1}{$\angles{\l{stack-model}\ t\ (\cons{v}{\v{old}}) \iSep \v{vs} \similar[phys] \v{old}}$}?
    
    ()
  else
    push t v
\end{minted}
\onslide<4-6>
\begin{minted}[escapeinside=??]{text}
let rec push t v =
  let old = Atomic.get t in
  let new = v :: old in
  ?\textcolor{color1}{$\angles[vs]{\l{stack-model}\ t\ \v{vs} \iSep \ldots }$}?
  if ?\textcolor{color2}{Atomic.compare\_and\_set}? t old new then
    ?\textcolor{color1}{$\angles{\l{stack-model}\ t\ (\cons{v}{\v{old}}) \iSep \v{vs} \similar[phys] \v{old}}$}?
    ?\textcolor{color1}{$\angles{\l{stack-model}\ t\ (\cons{v}{\v{vs}})}$}?
    ()
  else
    push t v
\end{minted}
\onslide<7>
\begin{minted}[escapeinside=??]{text}
let rec push t v =
  let old = Atomic.get t in
  let new = v :: old in
  ?\textcolor{color1}{$\angles[vs]{\l{stack-model}\ t\ \v{vs} \iSep \ldots }$}?
  if ?\textcolor{color2}{Atomic.compare\_and\_set}? t old new then
    ?\textcolor{color1}{$\angles{\l{stack-model}\ t\ (\cons{v}{\v{old}}) \iSep \v{vs} \similar[phys] \v{old}}$}?
    ?\textcolor{color1}{\st{$\angles{\l{stack-model}\ t\ (\cons{v}{\v{vs}})}$}}?
    ()
  else
    push t v
\end{minted}
\end{overprint}
\begin{overbox}<5>[width=.9]
\Large
\centering
\textbf{Sharing of immutable blocks}
\medskip
\medskip
\begin{ocamlcode}
let test1 = 1 :: [] == 1 :: []  (* maybe true *)
let test2 = 1 :: [] == 1 :: []  (* maybe false *)
\end{ocamlcode}
\medskip
\medskip
\[
  \begin{array}{lcl}
      v_1 \mystackrel{rocq}{=} v_2 &
      \centernot\implies &
      v_1 \similar[phys] v_2
  \end{array}
\]
\end{overbox}
\begin{overbox}<6>[width=.9]
\Large
\centering
\textbf{Value representation conflicts}
\medskip
\medskip
\begin{ocamlcode}
type any = Any : 'a -> any
let test1 = Any false == Any 0  (* maybe true *)
let test2 = Any None  == Any 0  (* maybe true *)
let test3 = Any []    == Any 0  (* maybe true *)
\end{ocamlcode}
\medskip
\medskip
\[
  \begin{array}{lcl}
%      \neg\ (v_1 \mystackrel{rocq}{=} v_2) &
%      \centernot\implies &
%      \neg\ (v_1 \similar[phys] v_2)
%    \\
      v_1 \similar[phys] v_2 &
      \centernot\implies &
      v_1 \mystackrel{rocq}{=} v_2
  \end{array}
\]
\end{overbox}
\end{frame}

%\begin{frame}[fragile]{When physical equality returns \c{false}}
%\large
%\begin{minted}[escapeinside=??]{text}
%let rec push t v =
%  let old = Atomic.get t in
%  let new = v :: old in
%  ?\textcolor{color1}{$\angles[vs]{\l{stack-model}\ t\ \v{vs} \iSep \ldots }$}?
%  if ?\textcolor{color2}{Atomic.compare\_and\_set}? t old new then
%    ()
%  else
%    ?\textcolor{color1}{$\angles{\l{stack-model}\ t\ \v{vs} \iSep \v{vs} \nonsimilar[phys] \v{old}}$}?
%    ?\textcolor{color1}{$\angles{\l{stack-model}\ t\ \v{vs}}$}?
%    push t v
%\end{minted}
%\end{frame}

\begin{frame}[fragile]{When physical equality returns \c{false}}
\begin{overprint}
\onslide<1>
\begin{minted}[escapeinside=??]{ocaml}
type state = Open of Unix.file_descr | Closing of (unit -> unit)
type t = { mutable state: state [@atomic]; ... }

let make fd = { state= Open fd; ... }
let close t = match t.state with
  | Closing _ -> false
  | Open fd as old ->
      let close () = Unix.close fd in
      let ?new? = Closing close in
      
      if Atomic.Loc.compare_and_set [%atomic.loc t.state] old ?new?
      then ... else
        
        
        false
\end{minted}
\onslide<2>
\begin{minted}[escapeinside=??]{text}
type state = Open of Unix.file_descr | Closing of (unit -> unit)
type t = { mutable state: state ?\textcolor{color3}{[@atomic]}?; ... }

let make fd = { state= Open fd; ... }

let close t = match t.state with
  | Closing _ -> false
  | Open fd as old ->
      let close () = Unix.close fd in
      let new = Closing close in
      
      if ?\textcolor{color2}{Atomic.Loc.compare\_and\_set}? ?\textcolor{color3}{[%atomic.loc}? t.state?\textcolor{color3}{]}? old new
      then ... else
        
        
        false
\end{minted}
\onslide<3>
\begin{minted}[escapeinside=??]{text}
type state = ?\textcolor{color2}{Open}? of Unix.file_descr | ?\textcolor{color3}{Closing}? of (unit -> unit)
type t = { mutable state: state [@atomic]; ... }

let make fd = { state= ?\textcolor{color2}{Open}? fd; ... }

let close t = match t.state with
  | ?\textcolor{color3}{Closing}? _ -> false
  | ?\textcolor{color2}{Open}? fd as old ->
      let close () = Unix.close fd in
      let new = ?\textcolor{color3}{Closing}? close in
      
      if Atomic.Loc.compare_and_set [%atomic.loc t.state] old new
      then ... else
        
        
        false
\end{minted}
\onslide<4>
\begin{minted}[escapeinside=??]{text}
type state = Open of Unix.file_descr | Closing of (unit -> unit)
type t = { mutable state: state [@atomic]; ... }

let make fd = { state= Open fd; ... }

let close t = match t.state with
  | Closing _ -> false
  | Open fd as old ->
      let close () = Unix.close fd in
      let new = Closing close in
      
      if ?\textcolor{color2}{Atomic.Loc.compare\_and\_set}? [%atomic.loc t.state] old new
      then ... else
        
        
        false
\end{minted}
\onslide<5>
\begin{minted}[escapeinside=??]{text}
type state = Open of Unix.file_descr | Closing of (unit -> unit)
type t = { mutable state: state [@atomic]; ... }

let make fd = { state= Open fd; ... }

let close t = match t.state with
  | Closing _ -> false
  | Open fd as old ->
      let close () = Unix.close fd in
      let new = Closing close in
      ?\textcolor{color1}{$\angles[\v{state}]{\recordGet{t}{state} \iPointsto \v{state} \iSep \ldots}$}?
      if ?\textcolor{color2}{Atomic.Loc.compare\_and\_set}? [%atomic.loc t.state] old new
      then ... else
        
        
        false
\end{minted}
\onslide<6>
\begin{minted}[escapeinside=??]{text}
type state = Open of Unix.file_descr | Closing of (unit -> unit)
type t = { mutable state: state [@atomic]; ... }

let make fd = { state= Open fd; ... }

let close t = match t.state with
  | Closing _ -> false
  | Open fd as old ->
      let close () = Unix.close fd in
      let new = Closing close in
      ?\textcolor{color1}{$\angles[\v{state}]{\recordGet{t}{state} \iPointsto \v{state} \iSep \ldots}$}?
      if ?\textcolor{color2}{Atomic.Loc.compare\_and\_set}? [%atomic.loc t.state] old new
      then ... else
        ?\textcolor{color1}{$\angles{\recordGet{t}{state} \iPointsto \v{state} \iSep \v{state} \nonsimilar[phys] \v{old} \iSep \ldots}$}?
        
        false
\end{minted}
\onslide<7-8>
\begin{minted}[escapeinside=??]{text}
type state = Open of Unix.file_descr | Closing of (unit -> unit)
type t = { mutable state: state [@atomic]; ... }

let make fd = { state= Open fd; ... }

let close t = match t.state with
  | Closing _ -> false
  | Open fd as old ->
      let close () = Unix.close fd in
      let new = Closing close in
      ?\textcolor{color1}{$\angles[\v{state}]{\recordGet{t}{state} \iPointsto \v{state} \iSep \ldots}$}?
      if ?\textcolor{color2}{Atomic.Loc.compare\_and\_set}? [%atomic.loc t.state] old new
      then ... else
        ?\textcolor{color1}{$\angles{\recordGet{t}{state} \iPointsto \v{state} \iSep \v{state} \nonsimilar[phys] \v{old} \iSep \ldots}$}?
        ?\textcolor{color1}{$\angles{\recordGet{t}{state} \iPointsto \constr{Closing}\ - \iSep \ldots}$}?
        false
\end{minted}
\onslide<9>
\begin{minted}[escapeinside=??]{text}
type state = Open of Unix.file_descr | Closing of (unit -> unit)
type t = { mutable state: state [@atomic]; ... }

let make fd = { state= Open fd; ... }

let close t = match t.state with
  | Closing _ -> false
  | Open fd as old ->
      let close () = Unix.close fd in
      let new = Closing close in
      ?\textcolor{color1}{$\angles[\v{state}]{\recordGet{t}{state} \iPointsto \v{state} \iSep \ldots}$}?
      if ?\textcolor{color2}{Atomic.Loc.compare\_and\_set}? [%atomic.loc t.state] old new
      then ... else
        ?\textcolor{color1}{$\angles{\recordGet{t}{state} \iPointsto \v{state} \iSep \v{state} \nonsimilar[phys] \v{old} \iSep \ldots}$}?
        ?\textcolor{color1}{\st{$\angles{\recordGet{t}{state} \iPointsto \constr{Closing}\ - \iSep \ldots}$}}?
        false
\end{minted}
\end{overprint}
\begin{overbox}<8>[width=.67]
\Large
\centering
\textbf{Unsharing of immutable blocks}
\medskip
\medskip
\begin{ocamlcode}
let x = Some 0
let test = x == x  (* maybe false *)
\end{ocamlcode}
\medskip
\medskip
\[
  \begin{array}{lcl}
      v_1^{\v{id}_1} \nonsimilar[phys] v_2^{\v{id}_2} &
      \centernot\implies &
      \v{id}_1 \mystackrel{rocq}{\neq} \v{id}_2
  \end{array}
\]
\begin{figure}
  \captionsetup{justification=centering}
  \begin{subfigure}[b]{.35\textwidth}
    \centering
    \includegraphics[height=2cm]{images/clement_allain.jpg}
    \caption*{\tiny \textbf{Clément Allain} \\ Impossible! Unique identity.}
  \end{subfigure}
  \begin{subfigure}[b]{.3\textwidth}
    \centering
    \includegraphics[height=2cm]{images/armael_gueneau.jpg}
    \caption*{\tiny \textbf{Armaël Guéneau} \\ This would be \emph{unsharing}.}
  \end{subfigure}
  \begin{subfigure}[b]{.3\textwidth}
    \centering
    \includegraphics[height=2cm]{images/vincent_laviron.jpg}
    \caption*{\tiny \textbf{Vincent Laviron} \\ It's possible!}
  \end{subfigure}
\end{figure}
\end{overbox}
\end{frame}

\begin{frame}[fragile]{Generative constructors}
\Large
\begin{minted}{ocaml}
type 'a glist =
  | Nil
  | Cons of 'a * 'a glist [@generative]

type state =
  | Open of Unix.file_descr [@generative] [@zoo.reveal]
  | Closing of (unit -> unit)
\end{minted}
\end{frame}
